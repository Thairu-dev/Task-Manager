{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Breakpoints = exports.BreakpointConstraint = void 0;\nvar _Utils = require(\"./Utils\");\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? Object(arguments[i]) : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction breakpointKey(breakpoint) {\n  return Array.isArray(breakpoint) ? breakpoint.join(\"-\") : breakpoint;\n}\nvar BreakpointConstraint;\n/**\n * Encapsulates all breakpoint data needed by the Media component. The data is\n * generated on initialization so no further runtime work is necessary.\n */\n\nexports.BreakpointConstraint = BreakpointConstraint;\n(function (BreakpointConstraint) {\n  BreakpointConstraint[\"at\"] = \"at\";\n  BreakpointConstraint[\"lessThan\"] = \"lessThan\";\n  BreakpointConstraint[\"greaterThan\"] = \"greaterThan\";\n  BreakpointConstraint[\"greaterThanOrEqual\"] = \"greaterThanOrEqual\";\n  BreakpointConstraint[\"between\"] = \"between\";\n})(BreakpointConstraint || (exports.BreakpointConstraint = BreakpointConstraint = {}));\nvar Breakpoints = /*#__PURE__*/function () {\n  _createClass(Breakpoints, null, [{\n    key: \"validKeys\",\n    value: function validKeys() {\n      return [BreakpointConstraint.at, BreakpointConstraint.lessThan, BreakpointConstraint.greaterThan, BreakpointConstraint.greaterThanOrEqual, BreakpointConstraint.between];\n    }\n  }]);\n  function Breakpoints(_breakpoints) {\n    var _this = this,\n      _this$_mediaQueries;\n    _classCallCheck(this, Breakpoints);\n    _defineProperty(this, \"_sortedBreakpoints\", void 0);\n    _defineProperty(this, \"_breakpoints\", void 0);\n    _defineProperty(this, \"_mediaQueries\", void 0);\n    _defineProperty(this, \"findBreakpointsForWidths\", function (fromWidth, throughWidth) {\n      var fromBreakpoint = _this.findBreakpointAtWidth(fromWidth);\n      if (!fromBreakpoint) {\n        return undefined;\n      }\n      var throughBreakpoint = _this.findBreakpointAtWidth(throughWidth);\n      if (!throughBreakpoint || fromBreakpoint === throughBreakpoint) {\n        return [fromBreakpoint];\n      } else {\n        return _this._sortedBreakpoints.slice(_this._sortedBreakpoints.indexOf(fromBreakpoint), _this._sortedBreakpoints.indexOf(throughBreakpoint) + 1);\n      }\n    });\n    _defineProperty(this, \"findBreakpointAtWidth\", function (width) {\n      return _this._sortedBreakpoints.find(function (breakpoint, i) {\n        var nextBreakpoint = _this._sortedBreakpoints[i + 1];\n        if (nextBreakpoint) {\n          return width >= _this._breakpoints[breakpoint] && width < _this._breakpoints[nextBreakpoint];\n        } else {\n          return width >= _this._breakpoints[breakpoint];\n        }\n      });\n    });\n    _defineProperty(this, \"valuesWithBreakpointProps\", function (values) {\n      var max = values.length;\n      var valueBreakpoints = [];\n      var lastTuple;\n      _this._sortedBreakpoints.forEach(function (breakpoint, i) {\n        var value = values[i];\n        if (i < max && (!lastTuple || lastTuple[0] !== value)) {\n          lastTuple = [value, [breakpoint]];\n          valueBreakpoints.push(lastTuple);\n        } else {\n          lastTuple[1].push(breakpoint);\n        }\n      });\n      return valueBreakpoints.map(function (_ref, i) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          value = _ref2[0],\n          breakpoints = _ref2[1];\n        var props = {};\n        if (i === valueBreakpoints.length - 1) {\n          props.greaterThanOrEqual = breakpoints[0];\n        } else if (breakpoints.length === 1) {\n          props.at = breakpoints[0];\n        } else {\n          // TODO: This is less than ideal, would be good to have a `through`\n          //       prop, which unlike `between` is inclusive.\n          props.between = [breakpoints[0], valueBreakpoints[i + 1][1][0]];\n        }\n        return [value, props];\n      });\n    });\n    this._breakpoints = _breakpoints;\n    this._sortedBreakpoints = Object.keys(_breakpoints).map(function (breakpoint) {\n      return [breakpoint, _breakpoints[breakpoint]];\n    }).sort(function (a, b) {\n      return a[1] < b[1] ? -1 : 1;\n    }).map(function (breakpointAndValue) {\n      return breakpointAndValue[0];\n    }); // List of all possible and valid `between` combinations\n\n    var betweenCombinations = this._sortedBreakpoints.slice(0, -1).reduce(function (acc, b1, i) {\n      return _toConsumableArray(acc).concat(_toConsumableArray(_this._sortedBreakpoints.slice(i + 1).map(function (b2) {\n        return [b1, b2];\n      })));\n    }, []);\n    this._mediaQueries = (_this$_mediaQueries = {}, _defineProperty(_this$_mediaQueries, BreakpointConstraint.at, this._createBreakpointQueries(BreakpointConstraint.at, this._sortedBreakpoints)), _defineProperty(_this$_mediaQueries, BreakpointConstraint.lessThan, this._createBreakpointQueries(BreakpointConstraint.lessThan, this._sortedBreakpoints.slice(1))), _defineProperty(_this$_mediaQueries, BreakpointConstraint.greaterThan, this._createBreakpointQueries(BreakpointConstraint.greaterThan, this._sortedBreakpoints.slice(0, -1))), _defineProperty(_this$_mediaQueries, BreakpointConstraint.greaterThanOrEqual, this._createBreakpointQueries(BreakpointConstraint.greaterThanOrEqual, this._sortedBreakpoints)), _defineProperty(_this$_mediaQueries, BreakpointConstraint.between, this._createBreakpointQueries(BreakpointConstraint.between, betweenCombinations)), _this$_mediaQueries);\n  }\n  _createClass(Breakpoints, [{\n    key: \"toVisibleAtBreakpointSet\",\n    value: function toVisibleAtBreakpointSet(breakpointProps) {\n      breakpointProps = this._normalizeProps(breakpointProps);\n      if (breakpointProps.lessThan) {\n        var breakpointIndex = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === breakpointProps.lessThan;\n        });\n        return this.sortedBreakpoints.slice(0, breakpointIndex);\n      } else if (breakpointProps.greaterThan) {\n        var _breakpointIndex = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === breakpointProps.greaterThan;\n        });\n        return this.sortedBreakpoints.slice(_breakpointIndex + 1);\n      } else if (breakpointProps.greaterThanOrEqual) {\n        var _breakpointIndex2 = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === breakpointProps.greaterThanOrEqual;\n        });\n        return this.sortedBreakpoints.slice(_breakpointIndex2);\n      } else if (breakpointProps.between) {\n        var between = breakpointProps.between;\n        var fromBreakpointIndex = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === between[0];\n        });\n        var toBreakpointIndex = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === between[1];\n        });\n        return this.sortedBreakpoints.slice(fromBreakpointIndex, toBreakpointIndex);\n      }\n      return [];\n    }\n  }, {\n    key: \"toRuleSets\",\n    value: function toRuleSets() {\n      var _this2 = this;\n      var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Breakpoints.validKeys();\n      var selectedMediaQueries = keys.reduce(function (mediaQueries, query) {\n        mediaQueries[query] = _this2._mediaQueries[query];\n        return mediaQueries;\n      }, {});\n      return Object.entries(selectedMediaQueries).reduce(function (acc, _ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          type = _ref4[0],\n          queries = _ref4[1];\n        queries.forEach(function (query, breakpoint) {\n          // We need to invert the query, such that it matches when we want the\n          // element to be hidden.\n          acc.push((0, _Utils.createRuleSet)((0, _Utils.createClassName)(type, breakpoint), \"not all and \".concat(query)));\n        });\n        return acc;\n      }, []);\n    }\n  }, {\n    key: \"shouldRenderMediaQuery\",\n    value: function shouldRenderMediaQuery(breakpointProps, onlyRenderAt) {\n      var _this3 = this;\n      breakpointProps = this._normalizeProps(breakpointProps);\n      if (breakpointProps.lessThan) {\n        var width = this._breakpoints[breakpointProps.lessThan];\n        var lowestAllowedWidth = Math.min.apply(Math, _toConsumableArray(onlyRenderAt.map(function (breakpoint) {\n          return _this3._breakpoints[breakpoint];\n        })));\n        return lowestAllowedWidth < width;\n      } else if (breakpointProps.greaterThan) {\n        var _width = this._breakpoints[this._findNextBreakpoint(breakpointProps.greaterThan)];\n        var highestAllowedWidth = Math.max.apply(Math, _toConsumableArray(onlyRenderAt.map(function (breakpoint) {\n          return _this3._breakpoints[breakpoint];\n        })));\n        return highestAllowedWidth >= _width;\n      } else if (breakpointProps.greaterThanOrEqual) {\n        var _width2 = this._breakpoints[breakpointProps.greaterThanOrEqual];\n        var _highestAllowedWidth = Math.max.apply(Math, _toConsumableArray(onlyRenderAt.map(function (breakpoint) {\n          return _this3._breakpoints[breakpoint];\n        })));\n        return _highestAllowedWidth >= _width2;\n      } else if (breakpointProps.between) {\n        // TODO: This is the only useful breakpoint to negate, but we’ll\n        //       we’ll see when/if we need it. We could then also decide\n        //       to add `oustide`.\n        var fromWidth = this._breakpoints[breakpointProps.between[0]];\n        var toWidth = this._breakpoints[breakpointProps.between[1]];\n        var allowedWidths = onlyRenderAt.map(function (breakpoint) {\n          return _this3._breakpoints[breakpoint];\n        });\n        return !(Math.max.apply(Math, _toConsumableArray(allowedWidths)) < fromWidth || Math.min.apply(Math, _toConsumableArray(allowedWidths)) >= toWidth);\n      }\n      return false;\n    }\n  }, {\n    key: \"_normalizeProps\",\n    value: function _normalizeProps(breakpointProps) {\n      if (breakpointProps.at) {\n        var fromIndex = this._sortedBreakpoints.indexOf(breakpointProps.at);\n        var to = this._sortedBreakpoints[fromIndex + 1];\n        return to ? {\n          between: [breakpointProps.at, to]\n        } : {\n          greaterThanOrEqual: breakpointProps.at\n        };\n      }\n      return breakpointProps;\n    }\n  }, {\n    key: \"_createBreakpointQuery\",\n    value: function _createBreakpointQuery(breakpointProps) {\n      breakpointProps = this._normalizeProps(breakpointProps);\n      if (breakpointProps.lessThan) {\n        var width = this._breakpoints[breakpointProps.lessThan];\n        return \"(max-width:\".concat(width - 0.02, \"px)\");\n      } else if (breakpointProps.greaterThan) {\n        var _width3 = this._breakpoints[this._findNextBreakpoint(breakpointProps.greaterThan)];\n        return \"(min-width:\".concat(_width3, \"px)\");\n      } else if (breakpointProps.greaterThanOrEqual) {\n        var _width4 = this._breakpoints[breakpointProps.greaterThanOrEqual];\n        return \"(min-width:\".concat(_width4, \"px)\");\n      } else if (breakpointProps.between) {\n        // TODO: This is the only useful breakpoint to negate, but we’ll\n        //       we’ll see when/if we need it. We could then also decide\n        //       to add `outside`.\n        var fromWidth = this._breakpoints[breakpointProps.between[0]];\n        var toWidth = this._breakpoints[breakpointProps.between[1]];\n        return \"(min-width:\".concat(fromWidth, \"px) and (max-width:\").concat(toWidth - 0.02, \"px)\");\n      }\n      throw new Error(\"Unexpected breakpoint props: \".concat(JSON.stringify(breakpointProps)));\n    }\n  }, {\n    key: \"_createBreakpointQueries\",\n    value: function _createBreakpointQueries(key, forBreakpoints) {\n      var _this4 = this;\n      return forBreakpoints.reduce(function (map, breakpoint) {\n        map.set(breakpointKey(breakpoint), _this4._createBreakpointQuery(_defineProperty({}, key, breakpoint)));\n        return map;\n      }, new Map());\n    }\n  }, {\n    key: \"_findNextBreakpoint\",\n    value: function _findNextBreakpoint(breakpoint) {\n      var nextBreakpoint = this._sortedBreakpoints[this._sortedBreakpoints.indexOf(breakpoint) + 1];\n      if (!nextBreakpoint) {\n        throw new Error(\"There is no breakpoint larger than \".concat(breakpoint));\n      }\n      return nextBreakpoint;\n    }\n  }, {\n    key: \"sortedBreakpoints\",\n    get: function get() {\n      return this._sortedBreakpoints;\n    }\n  }, {\n    key: \"dynamicResponsiveMediaQueries\",\n    get: function get() {\n      return Array.from(this._mediaQueries[BreakpointConstraint.at].entries()).reduce(function (acc, _ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n          k = _ref6[0],\n          v = _ref6[1];\n        return _objectSpread({}, acc, _defineProperty({}, k, v));\n      }, {});\n    }\n  }, {\n    key: \"largestBreakpoint\",\n    get: function get() {\n      return this._sortedBreakpoints[this._sortedBreakpoints.length - 1];\n    }\n  }]);\n  return Breakpoints;\n}();\nexports.Breakpoints = Breakpoints;","map":{"version":3,"names":["_Utils","require","breakpointKey","breakpoint","Array","isArray","join","BreakpointConstraint","Breakpoints","at","lessThan","greaterThan","greaterThanOrEqual","between","_breakpoints","_this","_this$_mediaQueries","_classCallCheck","_defineProperty","fromWidth","throughWidth","fromBreakpoint","findBreakpointAtWidth","undefined","throughBreakpoint","_sortedBreakpoints","slice","indexOf","width","find","i","nextBreakpoint","values","max","length","valueBreakpoints","lastTuple","forEach","value","push","map","_ref","_ref2","_slicedToArray","breakpoints","props","Object","keys","sort","a","b","breakpointAndValue","betweenCombinations","reduce","acc","b1","_toConsumableArray","concat","b2","_mediaQueries","_createBreakpointQueries","breakpointProps","_normalizeProps","breakpointIndex","sortedBreakpoints","findIndex","bp","_breakpointIndex","_breakpointIndex2","fromBreakpointIndex","toBreakpointIndex","_this2","arguments","validKeys","selectedMediaQueries","mediaQueries","query","entries","_ref3","_ref4","type","queries","createRuleSet","createClassName","onlyRenderAt","_this3","lowestAllowedWidth","Math","min","apply","_width","_findNextBreakpoint","highestAllowedWidth","_width2","_highestAllowedWidth","toWidth","allowedWidths","fromIndex","to","_width3","_width4","Error","JSON","stringify","key","forBreakpoints","_this4","set","_createBreakpointQuery","Map","from","_ref5","_ref6","k","v","_objectSpread"],"sources":["/home/joey/Development/code/se-prep/Phase-4/Task-Manager/node_modules/@artsy/fresnel/src/Breakpoints.ts"],"sourcesContent":["import { MediaBreakpointProps } from \"./Media\"\nimport { createRuleSet, createClassName } from \"./Utils\"\n\n/**\n * A union of possible breakpoint props.\n */\nexport type BreakpointConstraintKey = keyof MediaBreakpointProps\n\ntype ValueBreakpointPropsTuple<SizeValue, BreakpointKey> = [\n  SizeValue,\n  MediaBreakpointProps<BreakpointKey>\n]\n\ntype Tuple = [string, string]\n\nfunction breakpointKey(breakpoint: string | Tuple) {\n  return Array.isArray(breakpoint) ? breakpoint.join(\"-\") : breakpoint\n}\n\nexport enum BreakpointConstraint {\n  at = \"at\",\n  lessThan = \"lessThan\",\n  greaterThan = \"greaterThan\",\n  greaterThanOrEqual = \"greaterThanOrEqual\",\n  between = \"between\",\n}\n\n/**\n * Encapsulates all breakpoint data needed by the Media component. The data is\n * generated on initialization so no further runtime work is necessary.\n */\nexport class Breakpoints<BreakpointKey extends string> {\n  static validKeys() {\n    return [\n      BreakpointConstraint.at,\n      BreakpointConstraint.lessThan,\n      BreakpointConstraint.greaterThan,\n      BreakpointConstraint.greaterThanOrEqual,\n      BreakpointConstraint.between,\n    ]\n  }\n\n  private _sortedBreakpoints: ReadonlyArray<string>\n  private _breakpoints: Record<string, number>\n  private _mediaQueries: Record<BreakpointConstraint, Map<string, string>>\n\n  constructor(breakpoints: { [key: string]: number }) {\n    this._breakpoints = breakpoints\n\n    this._sortedBreakpoints = Object.keys(breakpoints)\n      .map(breakpoint => [breakpoint, breakpoints[breakpoint]])\n      .sort((a, b) => (a[1] < b[1] ? -1 : 1))\n      .map(breakpointAndValue => breakpointAndValue[0] as string)\n\n    // List of all possible and valid `between` combinations\n    const betweenCombinations = this._sortedBreakpoints\n      .slice(0, -1)\n      .reduce(\n        (acc: Tuple[], b1, i) => [\n          ...acc,\n          ...this._sortedBreakpoints.slice(i + 1).map(b2 => [b1, b2] as Tuple),\n        ],\n        []\n      )\n\n    this._mediaQueries = {\n      [BreakpointConstraint.at]: this._createBreakpointQueries(\n        BreakpointConstraint.at,\n        this._sortedBreakpoints\n      ),\n      [BreakpointConstraint.lessThan]: this._createBreakpointQueries(\n        BreakpointConstraint.lessThan,\n        this._sortedBreakpoints.slice(1)\n      ),\n      [BreakpointConstraint.greaterThan]: this._createBreakpointQueries(\n        BreakpointConstraint.greaterThan,\n        this._sortedBreakpoints.slice(0, -1)\n      ),\n      [BreakpointConstraint.greaterThanOrEqual]: this._createBreakpointQueries(\n        BreakpointConstraint.greaterThanOrEqual,\n        this._sortedBreakpoints\n      ),\n      [BreakpointConstraint.between]: this._createBreakpointQueries(\n        BreakpointConstraint.between,\n        betweenCombinations\n      ),\n    }\n  }\n\n  public get sortedBreakpoints() {\n    return this._sortedBreakpoints as BreakpointKey[]\n  }\n\n  public get dynamicResponsiveMediaQueries() {\n    return Array.from(\n      this._mediaQueries[BreakpointConstraint.at].entries()\n    ).reduce((acc, [k, v]) => ({ ...acc, [k]: v }), {})\n  }\n\n  public get largestBreakpoint() {\n    return this._sortedBreakpoints[this._sortedBreakpoints.length - 1]\n  }\n\n  public findBreakpointsForWidths = (\n    fromWidth: number,\n    throughWidth: number\n  ) => {\n    const fromBreakpoint = this.findBreakpointAtWidth(fromWidth)\n    if (!fromBreakpoint) {\n      return undefined\n    }\n    const throughBreakpoint = this.findBreakpointAtWidth(throughWidth)\n    if (!throughBreakpoint || fromBreakpoint === throughBreakpoint) {\n      return [fromBreakpoint] as BreakpointKey[]\n    } else {\n      return this._sortedBreakpoints.slice(\n        this._sortedBreakpoints.indexOf(fromBreakpoint),\n        this._sortedBreakpoints.indexOf(throughBreakpoint) + 1\n      ) as BreakpointKey[]\n    }\n  }\n\n  public findBreakpointAtWidth = (width: number) => {\n    return this._sortedBreakpoints.find((breakpoint, i) => {\n      const nextBreakpoint = this._sortedBreakpoints[i + 1]\n      if (nextBreakpoint) {\n        return (\n          width >= this._breakpoints[breakpoint] &&\n          width < this._breakpoints[nextBreakpoint]\n        )\n      } else {\n        return width >= this._breakpoints[breakpoint]\n      }\n    }) as BreakpointKey | undefined\n  }\n\n  public toVisibleAtBreakpointSet(breakpointProps: MediaBreakpointProps) {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const breakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === breakpointProps.lessThan\n      )\n      return this.sortedBreakpoints.slice(0, breakpointIndex)\n    } else if (breakpointProps.greaterThan) {\n      const breakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === breakpointProps.greaterThan\n      )\n      return this.sortedBreakpoints.slice(breakpointIndex + 1)\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const breakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === breakpointProps.greaterThanOrEqual\n      )\n      return this.sortedBreakpoints.slice(breakpointIndex)\n    } else if (breakpointProps.between) {\n      const between = breakpointProps.between\n      const fromBreakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === between[0]\n      )\n      const toBreakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === between[1]\n      )\n      return this.sortedBreakpoints.slice(\n        fromBreakpointIndex,\n        toBreakpointIndex\n      )\n    }\n    return []\n  }\n\n  public toRuleSets(keys = Breakpoints.validKeys()) {\n    const selectedMediaQueries = keys.reduce(\n      (mediaQueries, query) => {\n        mediaQueries[query] = this._mediaQueries[query]\n        return mediaQueries\n      },\n      {} as Record<BreakpointConstraint, Map<string, string>>\n    )\n\n    return Object.entries(selectedMediaQueries).reduce(\n      (acc: string[], [type, queries]) => {\n        queries.forEach((query, breakpoint) => {\n          // We need to invert the query, such that it matches when we want the\n          // element to be hidden.\n          acc.push(\n            createRuleSet(\n              createClassName(type, breakpoint),\n              `not all and ${query}`\n            )\n          )\n        })\n        return acc\n      },\n      []\n    )\n  }\n\n  public shouldRenderMediaQuery(\n    breakpointProps: MediaBreakpointProps,\n    onlyRenderAt: string[]\n  ): boolean {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const width = this._breakpoints[breakpointProps.lessThan]\n      const lowestAllowedWidth = Math.min(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return lowestAllowedWidth < width\n    } else if (breakpointProps.greaterThan) {\n      const width = this._breakpoints[\n        this._findNextBreakpoint(breakpointProps.greaterThan)\n      ]\n      const highestAllowedWidth = Math.max(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return highestAllowedWidth >= width\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const width = this._breakpoints[breakpointProps.greaterThanOrEqual]\n      const highestAllowedWidth = Math.max(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return highestAllowedWidth >= width\n    } else if (breakpointProps.between) {\n      // TODO: This is the only useful breakpoint to negate, but we’ll\n      //       we’ll see when/if we need it. We could then also decide\n      //       to add `oustide`.\n      const fromWidth = this._breakpoints[breakpointProps.between[0]]\n      const toWidth = this._breakpoints[breakpointProps.between[1]]\n      const allowedWidths = onlyRenderAt.map(\n        breakpoint => this._breakpoints[breakpoint]\n      )\n      return !(\n        Math.max(...allowedWidths) < fromWidth ||\n        Math.min(...allowedWidths) >= toWidth\n      )\n    }\n    return false\n  }\n\n  public valuesWithBreakpointProps = <SizeValue>(\n    values: SizeValue[]\n  ): ValueBreakpointPropsTuple<SizeValue, BreakpointKey>[] => {\n    type ValueBreakpoints = [SizeValue, string[]]\n    const max = values.length\n    const valueBreakpoints: ValueBreakpoints[] = []\n    let lastTuple: ValueBreakpoints\n    this._sortedBreakpoints.forEach((breakpoint, i) => {\n      const value = values[i]\n      if (i < max && (!lastTuple || lastTuple[0] !== value)) {\n        lastTuple = [value, [breakpoint]]\n        valueBreakpoints.push(lastTuple)\n      } else {\n        lastTuple[1].push(breakpoint)\n      }\n    })\n\n    return valueBreakpoints.map(([value, breakpoints], i) => {\n      const props: MediaBreakpointProps<any> = {}\n      if (i === valueBreakpoints.length - 1) {\n        props.greaterThanOrEqual = breakpoints[0]\n      } else if (breakpoints.length === 1) {\n        props.at = breakpoints[0]\n      } else {\n        // TODO: This is less than ideal, would be good to have a `through`\n        //       prop, which unlike `between` is inclusive.\n        props.between = [breakpoints[0], valueBreakpoints[i + 1][1][0]]\n      }\n      return [value, props] as ValueBreakpointPropsTuple<\n        SizeValue,\n        BreakpointKey\n      >\n    })\n  }\n\n  private _normalizeProps(\n    breakpointProps: MediaBreakpointProps\n  ): MediaBreakpointProps {\n    if (breakpointProps.at) {\n      const fromIndex = this._sortedBreakpoints.indexOf(breakpointProps.at)\n      const to = this._sortedBreakpoints[fromIndex + 1]\n      return to\n        ? { between: [breakpointProps.at, to] }\n        : { greaterThanOrEqual: breakpointProps.at }\n    }\n    return breakpointProps\n  }\n\n  private _createBreakpointQuery(\n    breakpointProps: MediaBreakpointProps\n  ): string {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const width = this._breakpoints[breakpointProps.lessThan]\n      return `(max-width:${width - 0.02}px)`\n    } else if (breakpointProps.greaterThan) {\n      const width = this._breakpoints[\n        this._findNextBreakpoint(breakpointProps.greaterThan)\n      ]\n      return `(min-width:${width}px)`\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const width = this._breakpoints[breakpointProps.greaterThanOrEqual]\n      return `(min-width:${width}px)`\n    } else if (breakpointProps.between) {\n      // TODO: This is the only useful breakpoint to negate, but we’ll\n      //       we’ll see when/if we need it. We could then also decide\n      //       to add `outside`.\n      const fromWidth = this._breakpoints[breakpointProps.between[0]]\n      const toWidth = this._breakpoints[breakpointProps.between[1]]\n      return `(min-width:${fromWidth}px) and (max-width:${toWidth - 0.02}px)`\n    }\n    throw new Error(\n      `Unexpected breakpoint props: ${JSON.stringify(breakpointProps)}`\n    )\n  }\n\n  private _createBreakpointQueries(\n    key: BreakpointConstraintKey,\n    forBreakpoints: ReadonlyArray<string | [string, string]>\n  ) {\n    return forBreakpoints.reduce<Map<string, string>>((map, breakpoint) => {\n      map.set(\n        breakpointKey(breakpoint),\n        this._createBreakpointQuery({\n          [key]: breakpoint,\n        })\n      )\n      return map\n    }, new Map())\n  }\n\n  private _findNextBreakpoint(breakpoint: string) {\n    const nextBreakpoint = this._sortedBreakpoints[\n      this._sortedBreakpoints.indexOf(breakpoint) + 1\n    ]\n    if (!nextBreakpoint) {\n      throw new Error(`There is no breakpoint larger than ${breakpoint}`)\n    }\n    return nextBreakpoint\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}