{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createMedia = createMedia;\nvar _react = _interopRequireDefault(require(\"react\"));\nvar _DynamicResponsive = require(\"./DynamicResponsive\");\nvar _MediaQueries = require(\"./MediaQueries\");\nvar _Utils = require(\"./Utils\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? Object(arguments[i]) : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\n/**\n * This is used to generate a Media component, its context provider, and CSS\n * rules based on your applicationâ€™s breakpoints and interactions.\n *\n * Note that the interaction queries are entirely up to you to define and they\n * should be written in such a way that they match when you want the element to\n * be hidden.\n *\n * @example\n *\n   ```tsx\n   const MyAppMedia = createMedia({\n     breakpoints: {\n       xs: 0,\n       sm: 768,\n       md: 900\n       lg: 1024,\n       xl: 1192,\n     },\n     interactions: {\n       hover: `not all and (hover:hover)`\n     },\n   })\n\n   export const Media = MyAppMedia.Media\n   export const MediaContextProvider = MyAppMedia.MediaContextProvider\n   export const createMediaStyle = MyAppMedia.createMediaStyle\n   ```\n *\n */\nfunction createMedia(config) {\n  var breakpoints = (0, _Utils.castBreakpointsToIntegers)(config.breakpoints);\n  var mediaQueries = new _MediaQueries.MediaQueries(breakpoints, config.interactions || {});\n  var DynamicResponsive = (0, _DynamicResponsive.createResponsiveComponents)();\n  var MediaContext = _react.default.createContext({});\n  MediaContext.displayName = \"Media.Context\";\n  var MediaParentContext = _react.default.createContext({\n    hasParentMedia: false,\n    breakpointProps: {}\n  });\n  MediaContext.displayName = \"MediaParent.Context\";\n  var getMediaContextValue = (0, _Utils.memoize)(function (onlyMatch) {\n    return {\n      onlyMatch: onlyMatch\n    };\n  });\n  var MediaContextProvider = function MediaContextProvider(_ref) {\n    var disableDynamicMediaQueries = _ref.disableDynamicMediaQueries,\n      onlyMatch = _ref.onlyMatch,\n      children = _ref.children;\n    if (disableDynamicMediaQueries) {\n      var MediaContextValue = getMediaContextValue(onlyMatch);\n      return _react.default.createElement(MediaContext.Provider, {\n        value: MediaContextValue\n      }, children);\n    } else {\n      return _react.default.createElement(DynamicResponsive.Provider, {\n        mediaQueries: mediaQueries.dynamicResponsiveMediaQueries,\n        initialMatchingMediaQueries: (0, _Utils.intersection)(mediaQueries.mediaQueryTypes, onlyMatch)\n      }, _react.default.createElement(DynamicResponsive.Consumer, null, function (matches) {\n        var matchingMediaQueries = Object.keys(matches).filter(function (key) {\n          return matches[key];\n        });\n        var MediaContextValue = getMediaContextValue((0, _Utils.intersection)(matchingMediaQueries, onlyMatch));\n        return _react.default.createElement(MediaContext.Provider, {\n          value: MediaContextValue\n        }, children);\n      }));\n    }\n  };\n  var Media = function Media(props) {\n    validateProps(props);\n    var children = props.children,\n      passedClassName = props.className,\n      style = props.style,\n      interaction = props.interaction,\n      breakpointProps = _objectWithoutProperties(props, [\"children\", \"className\", \"style\", \"interaction\"]);\n    var getMediaParentContextValue = _react.default.useMemo(function () {\n      return (0, _Utils.memoize)(function (newBreakpointProps) {\n        return {\n          hasParentMedia: true,\n          breakpointProps: newBreakpointProps\n        };\n      });\n    }, []);\n    var mediaParentContext = _react.default.useContext(MediaParentContext);\n    var childMediaParentContext = getMediaParentContextValue(breakpointProps);\n    var _React$useContext = _react.default.useContext(MediaContext),\n      onlyMatch = _React$useContext.onlyMatch;\n    var id = _react.default.useId();\n    var isClient = typeof window !== \"undefined\";\n    var isFirstRender = (0, _Utils.useIsFirstRender)();\n    var className;\n    if (props.interaction) {\n      className = (0, _Utils.createClassName)(\"interaction\", props.interaction);\n    } else {\n      if (props.at) {\n        var largestBreakpoint = mediaQueries.breakpoints.largestBreakpoint;\n        if (props.at === largestBreakpoint) {\n          console.warn(\"[@artsy/fresnel] \" + \"`at` is being used with the largest breakpoint. \" + \"Consider using `<Media greaterThanOrEqual=\" + \"\\\"\".concat(largestBreakpoint, \"\\\">` to account for future \") + \"breakpoint definitions outside of this range.\");\n        }\n      }\n      var type = (0, _Utils.propKey)(breakpointProps);\n      var breakpoint = breakpointProps[type];\n      className = (0, _Utils.createClassName)(type, breakpoint);\n    }\n    var doesMatchParent = !mediaParentContext.hasParentMedia || (0, _Utils.intersection)(mediaQueries.breakpoints.toVisibleAtBreakpointSet(mediaParentContext.breakpointProps), mediaQueries.breakpoints.toVisibleAtBreakpointSet(breakpointProps)).length > 0;\n    var renderChildren = doesMatchParent && (onlyMatch === undefined || mediaQueries.shouldRenderMediaQuery(_objectSpread({}, breakpointProps, {\n      interaction: interaction\n    }), onlyMatch)); // Append a unique id to the className (consistent on server and client)\n\n    var uniqueComponentId = \" fresnel-\".concat(id);\n    className += uniqueComponentId;\n    /**\n     * SPECIAL CASE:\n     * If we're on the client, this is the first render, and we are not going\n     * to render the children, we need to cleanup the the server-rendered HTML\n     * to avoid a hydration mismatch on React 18+. We do this by grabbing the\n     * already-existing element(s) directly from the DOM using the unique class\n     * id and clearing its contents. This solution follows one of the\n     * suggestions from Dan Abromov here:\n     *\n     * https://github.com/facebook/react/issues/23381#issuecomment-1096899474\n     *\n     * This will not have a negative impact on client-only rendering because\n     * either 1) isFirstRender will be false OR 2) the element won't exist yet\n     * so there will be nothing to clean up. It will only apply on SSR'd HTML\n     * on initial hydration.\n     */\n\n    if (isClient && isFirstRender && !renderChildren) {\n      var containerEls = document.getElementsByClassName(uniqueComponentId);\n      Array.from(containerEls).forEach(function (el) {\n        return el.innerHTML = \"\";\n      });\n    }\n    return _react.default.createElement(MediaParentContext.Provider, {\n      value: childMediaParentContext\n    }, function () {\n      if (props.children instanceof Function) {\n        return props.children(className, renderChildren);\n      } else {\n        return _react.default.createElement(\"div\", {\n          className: [\"fresnel-container\", className, passedClassName].filter(Boolean).join(\" \"),\n          style: style,\n          suppressHydrationWarning: true\n        }, renderChildren ? props.children : null);\n      }\n    }());\n  };\n  return {\n    Media: Media,\n    MediaContextProvider: MediaContextProvider,\n    createMediaStyle: mediaQueries.toStyle,\n    SortedBreakpoints: _toConsumableArray(mediaQueries.breakpoints.sortedBreakpoints),\n    findBreakpointAtWidth: mediaQueries.breakpoints.findBreakpointAtWidth,\n    findBreakpointsForWidths: mediaQueries.breakpoints.findBreakpointsForWidths,\n    valuesWithBreakpointProps: mediaQueries.breakpoints.valuesWithBreakpointProps\n  };\n}\nvar MutuallyExclusiveProps = _MediaQueries.MediaQueries.validKeys();\nfunction validateProps(props) {\n  var selectedProps = Object.keys(props).filter(function (prop) {\n    return MutuallyExclusiveProps.includes(prop);\n  });\n  if (selectedProps.length < 1) {\n    throw new Error(\"1 of \".concat(MutuallyExclusiveProps.join(\", \"), \" is required.\"));\n  } else if (selectedProps.length > 1) {\n    throw new Error(\"Only 1 of \".concat(selectedProps.join(\", \"), \" is allowed at a time.\"));\n  }\n}","map":{"version":3,"names":["_react","_interopRequireDefault","require","_DynamicResponsive","_MediaQueries","_Utils","createMedia","config","breakpoints","castBreakpointsToIntegers","mediaQueries","MediaQueries","interactions","DynamicResponsive","createResponsiveComponents","MediaContext","default","createContext","displayName","MediaParentContext","hasParentMedia","breakpointProps","getMediaContextValue","memoize","onlyMatch","MediaContextProvider","_ref","disableDynamicMediaQueries","children","MediaContextValue","createElement","Provider","value","dynamicResponsiveMediaQueries","initialMatchingMediaQueries","intersection","mediaQueryTypes","Consumer","matches","matchingMediaQueries","Object","keys","filter","key","Media","props","validateProps","passedClassName","className","style","interaction","_objectWithoutProperties","getMediaParentContextValue","useMemo","newBreakpointProps","mediaParentContext","useContext","childMediaParentContext","_React$useContext","id","useId","isClient","window","isFirstRender","useIsFirstRender","createClassName","at","largestBreakpoint","console","warn","concat","type","propKey","breakpoint","doesMatchParent","toVisibleAtBreakpointSet","length","renderChildren","undefined","shouldRenderMediaQuery","_objectSpread","uniqueComponentId","containerEls","document","getElementsByClassName","Array","from","forEach","el","innerHTML","Function","Boolean","join","suppressHydrationWarning","createMediaStyle","toStyle","SortedBreakpoints","_toConsumableArray","sortedBreakpoints","findBreakpointAtWidth","findBreakpointsForWidths","valuesWithBreakpointProps","MutuallyExclusiveProps","validKeys","selectedProps","prop","includes","Error"],"sources":["/home/joey/Development/code/se-prep/Phase-4/Task-Manager/node_modules/@artsy/fresnel/src/Media.tsx"],"sourcesContent":["// tslint:disable:jsdoc-format\n\nimport React, { CSSProperties } from \"react\"\nimport { createResponsiveComponents } from \"./DynamicResponsive\"\nimport { MediaQueries } from \"./MediaQueries\"\nimport {\n  intersection,\n  propKey,\n  createClassName,\n  castBreakpointsToIntegers,\n  memoize,\n  useIsFirstRender,\n} from \"./Utils\"\nimport { BreakpointConstraint } from \"./Breakpoints\"\n\n/**\n * A render prop that can be used to render a different container element than\n * the default `div`.\n *\n * @see {@link MediaProps.children}.\n */\nexport type RenderProp = (\n  className: string,\n  renderChildren: boolean\n) => React.ReactNode\n\n// TODO: All of these props should be mutually exclusive. Using a union should\n//       probably be made possible by https://github.com/Microsoft/TypeScript/pull/27408.\nexport interface MediaBreakpointProps<BreakpointKey = string> {\n  /**\n   * Children will only be shown if the viewport matches the specified\n   * breakpoint. That is, a viewport width thatâ€™s higher than the configured\n   * breakpoint value, but lower than the value of the next breakpoint, if any\n   * larger breakpoints exist at all.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width between 0 and 768\n     <Media at=\"xs\">ohai</Media>\n\n     // Matches a viewport that has a width between 768 and 1024\n     <Media at=\"sm\">ohai</Media>\n\n     // Matches a viewport that has a width over 1024\n     <Media at=\"md\">ohai</Media>\n     ```\n   *\n   */\n  at?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is smaller than the specified\n   * breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n    // Matches a viewport that has a width from 0 to 767\n     <Media lessThan=\"sm\">ohai</Media>\n\n     // Matches a viewport that has a width from 0 to 1023\n     <Media lessThan=\"md\">ohai</Media>\n     ```\n   *\n   */\n  lessThan?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is greater than the specified\n   * breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width from 768 to infinity\n     <Media greaterThan=\"xs\">ohai</Media>\n\n     // Matches a viewport that has a width from 1024 to infinity\n     <Media greaterThan=\"sm\">ohai</Media>\n     ```\n   *\n   */\n  greaterThan?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is greater or equal to the\n   * specified breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width from 0 to infinity\n     <Media greaterThanOrEqual=\"xs\">ohai</Media>\n\n     // Matches a viewport that has a width from 768 to infinity\n     <Media greaterThanOrEqual=\"sm\">ohai</Media>\n\n     // Matches a viewport that has a width from 1024 to infinity\n     <Media greaterThanOrEqual=\"md\">ohai</Media>\n     ```\n   *\n   */\n  greaterThanOrEqual?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is between the specified\n   * breakpoints. That is, a viewport width thatâ€™s higher than or equal to the\n   * small breakpoint value, but lower than the value of the large breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width from 0 to 767\n     <Media between={[\"xs\", \"sm\"]}>ohai</Media>\n\n     // Matches a viewport that has a width from 0 to 1023\n     <Media between={[\"xs\", \"md\"]}>ohai</Media>\n     ```\n   *\n   */\n  between?: [BreakpointKey, BreakpointKey]\n}\n\nexport interface MediaProps<BreakpointKey, Interaction>\n  extends MediaBreakpointProps<BreakpointKey> {\n  /**\n   * Children will only be shown if the interaction query matches.\n   *\n   * @example\n\n     ```tsx\n     // With interactions defined like these\n     { hover: \"(hover: hover)\" }\n\n     // Matches an input device that is capable of hovering\n     <Media interaction=\"hover\">ohai</Media>\n     ```\n   */\n  interaction?: Interaction\n\n  /**\n   * The component(s) that should conditionally be shown, depending on the media\n   * query matching.\n   *\n   * In case a different element is preferred, a render prop can be provided\n   * that receives the class-name it should use to have the media query styling\n   * applied.\n   *\n   * Additionally, the render prop receives a boolean that indicates wether or\n   * not its children should be rendered, which will be `false` if the media\n   * query is not included in the `onlyMatch` list. Use this flag if your\n   * componentâ€™s children may be expensive to render and you want to avoid any\n   * unnecessary work.\n   * (@see {@link MediaContextProviderProps.onlyMatch} for details)\n   *\n   * @example\n   *\n     ```tsx\n     const Component = () => (\n       <Media greaterThan=\"xs\">\n         {(className, renderChildren) => (\n           <span className={className}>\n             {renderChildren && \"ohai\"}\n           </span>\n         )}\n       </Media>\n     )\n     ```\n   *\n   */\n  children: React.ReactNode | RenderProp\n\n  /**\n   * Additional classNames to passed down and applied to Media container\n   */\n  className?: string\n\n  /**\n   * Additional styles to passed down and applied to Media container\n   */\n  style?: CSSProperties\n}\n\nexport interface MediaContextProviderProps<M> {\n  /**\n   * This list of breakpoints and interactions can be used to limit the rendered\n   * output to these.\n   *\n   * For instance, when a server knows for some user-agents that certain\n   * breakpoints will never apply, omitting them altogether will lower the\n   * rendered byte size.\n   */\n  onlyMatch?: M[]\n\n  /**\n   * Disables usage of browser MediaQuery API to only render at the current\n   * breakpoint.\n   *\n   * Use this with caution, as disabling this means React components for all\n   * breakpoints will be mounted client-side and all associated life-cycle hooks\n   * will be triggered, which could lead to unintended side-effects.\n   */\n  disableDynamicMediaQueries?: boolean\n}\n\nexport interface CreateMediaConfig {\n  /**\n   * The breakpoint definitions for your application. Width definitions should\n   * start at 0.\n   *\n   * @see {@link createMedia}\n   */\n  breakpoints: { [key: string]: number | string }\n\n  /**\n   * The interaction definitions for your application.\n   */\n  interactions?: { [key: string]: string }\n}\n\nexport interface CreateMediaResults<BreakpointKey, Interactions> {\n  /**\n   * The React component that you use throughout your application.\n   *\n   * @see {@link MediaBreakpointProps}\n   */\n  Media: React.ComponentType<MediaProps<BreakpointKey, Interactions>>\n\n  /**\n   * The React Context provider component that you use to constrain rendering of\n   * breakpoints to a set list and to enable client-side dynamic constraining.\n   *\n   * @see {@link MediaContextProviderProps}\n   */\n  MediaContextProvider: React.ComponentType<\n    MediaContextProviderProps<BreakpointKey | Interactions> & {\n      children: React.ReactNode\n    }\n  >\n\n  /**\n   * Generates a set of CSS rules that you should include in your applicationâ€™s\n   * styling to enable the hiding behaviour of your `Media` component uses.\n   */\n  createMediaStyle(breakpointKeys?: BreakpointConstraint[]): string\n\n  /**\n   * A list of your applicationâ€™s breakpoints sorted from small to large.\n   */\n  SortedBreakpoints: BreakpointKey[]\n\n  /**\n   * Creates a list of your applicationâ€™s breakpoints that support the given\n   * widths and everything in between.\n   */\n  findBreakpointsForWidths(\n    fromWidth: number,\n    throughWidth: number\n  ): BreakpointKey[] | undefined\n\n  /**\n   * Finds the breakpoint that matches the given width.\n   */\n  findBreakpointAtWidth(width: number): BreakpointKey | undefined\n\n  /**\n   * Maps a list of values for various breakpoints to props that can be used\n   * with the `Media` component.\n   *\n   * The values map to corresponding indices in the sorted breakpoints array. If\n   * less values are specified than the number of breakpoints your application\n   * has, the last value will be applied to all subsequent breakpoints.\n   */\n  valuesWithBreakpointProps<SizeValue>(\n    values: SizeValue[]\n  ): [SizeValue, MediaBreakpointProps<BreakpointKey>][]\n}\n\n/**\n * This is used to generate a Media component, its context provider, and CSS\n * rules based on your applicationâ€™s breakpoints and interactions.\n *\n * Note that the interaction queries are entirely up to you to define and they\n * should be written in such a way that they match when you want the element to\n * be hidden.\n *\n * @example\n *\n   ```tsx\n   const MyAppMedia = createMedia({\n     breakpoints: {\n       xs: 0,\n       sm: 768,\n       md: 900\n       lg: 1024,\n       xl: 1192,\n     },\n     interactions: {\n       hover: `not all and (hover:hover)`\n     },\n   })\n\n   export const Media = MyAppMedia.Media\n   export const MediaContextProvider = MyAppMedia.MediaContextProvider\n   export const createMediaStyle = MyAppMedia.createMediaStyle\n   ```\n *\n */\nexport function createMedia<\n  MediaConfig extends CreateMediaConfig,\n  BreakpointKey extends keyof MediaConfig[\"breakpoints\"],\n  Interaction extends keyof MediaConfig[\"interactions\"]\n>(config: MediaConfig): CreateMediaResults<BreakpointKey, Interaction> {\n  const breakpoints = castBreakpointsToIntegers(config.breakpoints)\n\n  const mediaQueries = new MediaQueries<BreakpointKey>(\n    breakpoints,\n    config.interactions || {}\n  )\n\n  const DynamicResponsive = createResponsiveComponents()\n\n  const MediaContext = React.createContext<\n    MediaContextProviderProps<BreakpointKey | Interaction>\n  >({})\n  MediaContext.displayName = \"Media.Context\"\n\n  type MediaParentContextValue = {\n    hasParentMedia: boolean\n    breakpointProps: MediaBreakpointProps<BreakpointKey>\n  }\n\n  const MediaParentContext = React.createContext<MediaParentContextValue>({\n    hasParentMedia: false,\n    breakpointProps: {},\n  })\n  MediaContext.displayName = \"MediaParent.Context\"\n\n  const getMediaContextValue = memoize(onlyMatch => ({\n    onlyMatch,\n  }))\n\n  const MediaContextProvider: React.FunctionComponent<\n    MediaContextProviderProps<BreakpointKey | Interaction> & {\n      children?: React.ReactNode\n    }\n  > = ({ disableDynamicMediaQueries, onlyMatch, children }) => {\n    if (disableDynamicMediaQueries) {\n      const MediaContextValue = getMediaContextValue(onlyMatch)\n\n      return (\n        <MediaContext.Provider value={MediaContextValue}>\n          {children}\n        </MediaContext.Provider>\n      )\n    } else {\n      return (\n        <DynamicResponsive.Provider\n          mediaQueries={mediaQueries.dynamicResponsiveMediaQueries}\n          initialMatchingMediaQueries={intersection(\n            mediaQueries.mediaQueryTypes,\n            onlyMatch\n          )}\n        >\n          <DynamicResponsive.Consumer>\n            {matches => {\n              const matchingMediaQueries = Object.keys(matches).filter(\n                key => matches[key]\n              )\n\n              const MediaContextValue = getMediaContextValue(\n                intersection(matchingMediaQueries, onlyMatch)\n              )\n\n              return (\n                <MediaContext.Provider value={MediaContextValue}>\n                  {children}\n                </MediaContext.Provider>\n              )\n            }}\n          </DynamicResponsive.Consumer>\n        </DynamicResponsive.Provider>\n      )\n    }\n  }\n\n  const Media = (props: MediaProps<BreakpointKey, Interaction>) => {\n    validateProps(props)\n\n    const {\n      children,\n      className: passedClassName,\n      style,\n      interaction,\n      ...breakpointProps\n    } = props\n\n    const getMediaParentContextValue = React.useMemo(() => {\n      return memoize(\n        (newBreakpointProps: MediaBreakpointProps<BreakpointKey>) => ({\n          hasParentMedia: true,\n          breakpointProps: newBreakpointProps,\n        })\n      )\n    }, [])\n\n    const mediaParentContext = React.useContext(MediaParentContext)\n    const childMediaParentContext = getMediaParentContextValue(breakpointProps)\n    const { onlyMatch } = React.useContext(MediaContext)\n\n    const id = React.useId()\n    const isClient = typeof window !== \"undefined\"\n    const isFirstRender = useIsFirstRender()\n\n    let className: string | null\n    if (props.interaction) {\n      className = createClassName(\"interaction\", props.interaction)\n    } else {\n      if (props.at) {\n        const largestBreakpoint = mediaQueries.breakpoints.largestBreakpoint\n        if (props.at === largestBreakpoint) {\n          console.warn(\n            \"[@artsy/fresnel] \" +\n              \"`at` is being used with the largest breakpoint. \" +\n              \"Consider using `<Media greaterThanOrEqual=\" +\n              `\"${largestBreakpoint}\">\\` to account for future ` +\n              `breakpoint definitions outside of this range.`\n          )\n        }\n      }\n\n      const type = propKey(breakpointProps)\n      const breakpoint = breakpointProps[type]!\n      className = createClassName(type, breakpoint)\n    }\n\n    const doesMatchParent =\n      !mediaParentContext.hasParentMedia ||\n      intersection(\n        mediaQueries.breakpoints.toVisibleAtBreakpointSet(\n          mediaParentContext.breakpointProps\n        ),\n        mediaQueries.breakpoints.toVisibleAtBreakpointSet(breakpointProps)\n      ).length > 0\n\n    const renderChildren =\n      doesMatchParent &&\n      (onlyMatch === undefined ||\n        mediaQueries.shouldRenderMediaQuery(\n          { ...breakpointProps, interaction },\n          onlyMatch\n        ))\n\n    // Append a unique id to the className (consistent on server and client)\n    const uniqueComponentId = ` fresnel-${id}`\n    className += uniqueComponentId\n\n    /**\n     * SPECIAL CASE:\n     * If we're on the client, this is the first render, and we are not going\n     * to render the children, we need to cleanup the the server-rendered HTML\n     * to avoid a hydration mismatch on React 18+. We do this by grabbing the\n     * already-existing element(s) directly from the DOM using the unique class\n     * id and clearing its contents. This solution follows one of the\n     * suggestions from Dan Abromov here:\n     *\n     * https://github.com/facebook/react/issues/23381#issuecomment-1096899474\n     *\n     * This will not have a negative impact on client-only rendering because\n     * either 1) isFirstRender will be false OR 2) the element won't exist yet\n     * so there will be nothing to clean up. It will only apply on SSR'd HTML\n     * on initial hydration.\n     */\n    if (isClient && isFirstRender && !renderChildren) {\n      const containerEls = document.getElementsByClassName(uniqueComponentId)\n      Array.from(containerEls).forEach(el => (el.innerHTML = \"\"))\n    }\n\n    return (\n      <MediaParentContext.Provider value={childMediaParentContext}>\n        {(() => {\n          if (props.children instanceof Function) {\n            return props.children(className, renderChildren)\n          } else {\n            return (\n              <div\n                className={[\"fresnel-container\", className, passedClassName]\n                  .filter(Boolean)\n                  .join(\" \")}\n                style={style}\n                suppressHydrationWarning\n              >\n                {renderChildren ? props.children : null}\n              </div>\n            )\n          }\n        })()}\n      </MediaParentContext.Provider>\n    )\n  }\n\n  return {\n    Media,\n    MediaContextProvider,\n    createMediaStyle: mediaQueries.toStyle,\n    SortedBreakpoints: [...mediaQueries.breakpoints.sortedBreakpoints],\n    findBreakpointAtWidth: mediaQueries.breakpoints.findBreakpointAtWidth,\n    findBreakpointsForWidths: mediaQueries.breakpoints.findBreakpointsForWidths,\n    valuesWithBreakpointProps:\n      mediaQueries.breakpoints.valuesWithBreakpointProps,\n  }\n}\n\nconst MutuallyExclusiveProps: string[] = MediaQueries.validKeys()\n\nfunction validateProps(props) {\n  const selectedProps = Object.keys(props).filter(prop =>\n    MutuallyExclusiveProps.includes(prop)\n  )\n  if (selectedProps.length < 1) {\n    throw new Error(`1 of ${MutuallyExclusiveProps.join(\", \")} is required.`)\n  } else if (selectedProps.length > 1) {\n    throw new Error(\n      `Only 1 of ${selectedProps.join(\", \")} is allowed at a time.`\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}