{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.propKey = propKey;\nexports.intersection = intersection;\nexports.createRuleSet = createRuleSet;\nexports.createClassName = createClassName;\nexports.castBreakpointsToIntegers = castBreakpointsToIntegers;\nexports.memoize = memoize;\nexports.useIsFirstRender = useIsFirstRender;\nvar _react = require(\"react\");\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? Object(arguments[i]) : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\n\n/**\n * Extracts the single breakpoint prop from the props object.\n */\nfunction propKey(breakpointProps) {\n  return Object.keys(breakpointProps)[0];\n}\n/**\n * Returns the intersection of two arrays.\n */\n\nfunction intersection(a1, a2) {\n  return a2 ? a1.filter(function (element) {\n    return a2.indexOf(element) >= 0;\n  }) : _toConsumableArray(a1);\n}\n/**\n * Generate a style rule for a given class name that will hide the element\n * when the given query matches.\n */\n\nfunction createRuleSet(className, query) {\n  return \"@media \".concat(query, \"{.\").concat(className, \"{display:none!important;}}\");\n}\n/**\n * Given a list of strings, or string tuples, generates a class name.\n */\n\nfunction createClassName() {\n  for (var _len = arguments.length, components = new Array(_len), _key = 0; _key < _len; _key++) {\n    components[_key] = arguments[_key];\n  }\n  return [\"fresnel\"].concat(_toConsumableArray(components.reduce(function (acc, breakpoint) {\n    return Array.isArray(breakpoint) ? _toConsumableArray(acc).concat(_toConsumableArray(breakpoint)) : _toConsumableArray(acc).concat([breakpoint]);\n  }, []))).join(\"-\");\n}\n/**\n * Returns an object with every values casted to integers.\n */\n\nfunction castBreakpointsToIntegers(breakpoints) {\n  var keys = Object.keys(breakpoints);\n  return keys.reduce(function (previous, current, currentIndex) {\n    return _objectSpread({}, previous, _defineProperty({}, keys[currentIndex], Math.round(Number(breakpoints[current]))));\n  }, {});\n}\n/**\n * Use this function to memoize any function\n */\n\nfunction memoize(func) {\n  var results = {};\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    var argsKey = JSON.stringify(args);\n    if (!results[argsKey]) {\n      results[argsKey] = func.apply(void 0, args);\n    }\n    return results[argsKey];\n  };\n}\n/**\n * Hook to determine if the current render is the first render.\n */\n\nfunction useIsFirstRender() {\n  var isFirst = (0, _react.useRef)(true);\n  if (isFirst.current) {\n    isFirst.current = false;\n    return true;\n  } else {\n    return false;\n  }\n}","map":{"version":3,"names":["_react","require","propKey","breakpointProps","Object","keys","intersection","a1","a2","filter","element","indexOf","_toConsumableArray","createRuleSet","className","query","concat","createClassName","_len","arguments","length","components","Array","_key","reduce","acc","breakpoint","isArray","join","castBreakpointsToIntegers","breakpoints","previous","current","currentIndex","_objectSpread","_defineProperty","Math","round","Number","memoize","func","results","_len2","args","_key2","argsKey","JSON","stringify","apply","useIsFirstRender","isFirst","useRef"],"sources":["/home/joey/Development/code/se-prep/Phase-4/Task-Manager/node_modules/@artsy/fresnel/src/Utils.ts"],"sourcesContent":["import { MediaBreakpointProps } from \"./Media\"\nimport { BreakpointConstraintKey } from \"./Breakpoints\"\nimport { useRef } from \"react\"\n\n/**\n * Extracts the single breakpoint prop from the props object.\n */\nexport function propKey(breakpointProps: MediaBreakpointProps) {\n  return Object.keys(breakpointProps)[0] as BreakpointConstraintKey\n}\n\n/**\n * Returns the intersection of two arrays.\n */\nexport function intersection(\n  a1: ReadonlyArray<any>,\n  a2?: ReadonlyArray<any>\n): any[] {\n  return a2 ? a1.filter(element => a2.indexOf(element) >= 0) : [...a1]\n}\n\n/**\n * Generate a style rule for a given class name that will hide the element\n * when the given query matches.\n */\nexport function createRuleSet(className: string, query: string) {\n  return `@media ${query}{.${className}{display:none!important;}}`\n}\n\n/**\n * Given a list of strings, or string tuples, generates a class name.\n */\nexport function createClassName(\n  ...components: Array<string | [string, string]>\n) {\n  return [\n    \"fresnel\",\n    ...components.reduce(\n      (acc: string[], breakpoint) =>\n        Array.isArray(breakpoint)\n          ? [...acc, ...breakpoint]\n          : [...acc, breakpoint],\n      []\n    ),\n  ].join(\"-\")\n}\n\n/**\n * Returns an object with every values casted to integers.\n */\nexport function castBreakpointsToIntegers(breakpoints: {\n  [key: string]: number | string\n}): { [key: string]: number } {\n  const keys = Object.keys(breakpoints)\n\n  return keys.reduce(\n    (previous, current, currentIndex) => ({\n      ...previous,\n      [keys[currentIndex]]: Math.round(Number(breakpoints[current])),\n    }),\n    {}\n  )\n}\n\n/**\n * Use this function to memoize any function\n */\nexport function memoize<F extends (...args: any[]) => void>(func: F) {\n  const results = {}\n  return (...args) => {\n    const argsKey = JSON.stringify(args)\n    if (!results[argsKey]) {\n      results[argsKey] = func(...args)\n    }\n    return results[argsKey]\n  }\n}\n\n/**\n * Hook to determine if the current render is the first render.\n */\nexport function useIsFirstRender(): boolean {\n  const isFirst = useRef(true)\n\n  if (isFirst.current) {\n    isFirst.current = false\n    return true\n  } else {\n    return false\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}